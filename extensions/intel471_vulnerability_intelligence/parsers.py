import datetime
import json
import uuid
import structlog
from dev_kit.eiq_edk.schemas.entities import (
    ExtractType,
    ExploitTargetDataSchema,
    ProducerSchema,
    EntitySchema,
    ObservableSchema,
    ObservableObjectSchema,
    VulnerabilitySchema,
    CvssScoreSchema,
)
from marshmallow import ValidationError
from xml.sax import saxutils

log = structlog.get_logger(__name__)


def transform_vulnerabilities_reports(raw_data: bytes) -> dict:
#    log.info("Transformer started")
    cve_report = raw_data["raw_data"] or None

    if not cve_report:
#        log.info("Transformer run into error")
        raise ValueError(f"raw_data is empty {len(raw_data) , raw_data}")

    entities, relations = [], []
    exploit_target = make_exploit_target(cve_report)
    entities.append(exploit_target)
    exploit_target_index = len(entities) - 1
    entities.append(create_vulnerability_report(cve_report))
    relations.append(
        {
            "data": {
                "source": len(entities) - 1,
                "target": exploit_target_index,
                "key": "exploit_targets",
                "source_type": "report",
                "target_type": "exploit-target",
                "type": "relation",
            }
        }
    )
    return {"type": "linked-entities", "entities": entities, "relations": relations}


def make_exploit_target(report: dict) -> dict:
    cve_report = report["data"]["cve_report"]
    tags, bundled_extracts = [], []
    if report.get("classification"):
        tags = create_intel_requirements_tags(
            report["classification"].get("intel_requirements")
        )
    estimated_observed_start_time = datetime.datetime.utcfromtimestamp(
        report["activity"]["first"] / 1000
    ).isoformat()
    role, references = get_roles_references(cve_report)
    _id = "{{https://www.intel471.com/}}ExploitTarget-{}".format(
        str(uuid.uuid5(uuid.NAMESPACE_X500, str(cve_report["name"])))
    )
    producer = create_producer(
        "Intel 471 Vulnerability Intelligence",
        references=references,
        role_values=[role],
    )
    cve_value = cve_report["name"].replace("CVE-", "")
    cve_extract = {
        "kind": ExtractType.CVE.value,
        "value": cve_value,
        "classification": "safe",
    }

    if cve_extract:
        bundled_extracts = [cve_extract]

    exploit_target = create_exploit_target(
        _id,
        cve_report["name"],
        vulnerabilities=make_vulnerability(cve_report),
        description=f'<p>{cve_report["summary"]}</p>',
        producer=producer,
        extracts=bundled_extracts,
        tags=tags,
        observed_time=estimated_observed_start_time,
        timestamp=estimated_observed_start_time,
    )
    return exploit_target


# This is information source that is going to be used for all the other entities.
def create_producer(
    identity_name: str,
    references: list = None,
    role_values: list = None,
    description: str = "",
) -> dict:

    producer = ProducerSchema().load(
        {"identity": identity_name, "references": references, "roles": role_values}
    )

    return producer


def make_vulnerability(report: dict) -> list:
    versions_list, vulnerabilities_list = [], []
    versions = ""
    cpe23uri_list = set()
    for node in report.get("cpe", dict()).get("nodes", []):
        for cpe in node.get("cpe_match", []):
            if cpe.get("versionEndIncluding"):
                versions_list.append(cpe.get("versionEndIncluding"))
            if cpe.get("cpe23Uri"):
                cpe23uri_list.add(cpe.get("cpe23Uri"))
    if versions_list:
        versions = ", ".join(map(str, versions_list))
    references = [link.get("url") for link in report.get("titan_links", [])]
    references.append("https://api.intel471.com/v1/cve/reports")
    vulnerability = {}

    cvss_score = report.get("cvss_score")
    score = None
    if cvss_score and cvss_score.get("v3"):
        overall_score = cvss_score.get("v3")
        try:
            score = CvssScoreSchema().load({"overall_score": str(overall_score)})
        except ValidationError:
            raise ValidationError(
                f"CvssScore schema contains not valid fields: {score} "
            )

    try:
        vulnerability = VulnerabilitySchema().load(
            {
                "cve_id": report["name"],
                "title": report["name"],
                "references": references,
                "cvss_score": score,
            }
        )
    except ValidationError:
        raise ValidationError(
            f"Vulnerability schema contains not valid fields: {vulnerability} "
        )

    if not cpe23uri_list:
        vulnerabilities_list.append(vulnerability)

    for cpe23uri in sorted(list(cpe23uri_list)):
        # new_vulnerability = copy.deepcopy(vulnerability)

        observable_object = ObservableObjectSchema().load(
            {
                "id": "{{https://www.intel471.com/}}Product-{}".format(
                    str(uuid.uuid5(uuid.NAMESPACE_X500, str(report["product_name"])))
                ),
                "properties_xml": """
                    <cybox:Properties
                        xmlns:cybox="http://cybox.mitre.org/cybox-2"
                        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                        xmlns:ProductObj="http://cybox.mitre.org/objects#ProductObject-2"
                        xsi:type="ProductObj:ProductObjectType">
                        <ProductObj:Product>{}</ProductObj:Product>
                        <ProductObj:Vendor>{}</ProductObj:Vendor>
                        <ProductObj:Version>{}</ProductObj:Version>
                    </cybox:Properties>
                    """.format(
                    saxutils.escape(cpe23uri),
                    saxutils.escape(report["vendor_name"]),
                    versions,
                ),
            }
        )

        affected_software = {}
        affected_software = ObservableSchema().load(
            {
                "type": "observable",
                "id": "{{https://www.intel471.com/}}Observable-{}".format(
                    str(uuid.uuid5(uuid.NAMESPACE_X500, str(report["name"])))
                ),
                "object": observable_object,
            }
        )

        new_vulnerability = {}
        # ['affected_software'] = affected_software

        new_vulnerability = VulnerabilitySchema().load(
            {
                "cve_id": report["name"],
                "title": report["name"],
                "references": references,
                "cvss_score": score,
                "affected_software": [affected_software],
            }
        )
        vulnerabilities_list.append(new_vulnerability)

    return vulnerabilities_list


def create_intel_requirements_tags(requirements: list) -> list:
    tags = []
    for requirement in requirements:
        if requirement in intel_requirements_map:
            tags.append(
                f"Intelligence Requirement - " f"{intel_requirements_map[requirement]}"
            )
    return tags


def get_roles_references(report):
    role = "Aggregator"
    references = ["https://api.intel471.com/v1/cve/reports"]
    for titan_link in report.get("titan_links", []):
        if "intel471.com" in titan_link["url"]:
            role = "Initial Author"
        references.append(titan_link["url"])
    return role, references


def create_exploit_target(
    stix_id: str,
    title: str,
    description: str = "",
    producer: dict = "",
    observed_time: str = "",
    threat_start_time: str = "",
    threat_end_time: str = "",
    timestamp: str = "",
    extracts: list = [],
    tags: list = [],
    summary: str = "",
    extraction_ignore_paths: list = [],
    tlp_color: str = None,
    half_life: int = 1,
    observable: list = [],
    taxonomy: list = [],
    taxonomy_paths: list = [],
    vulnerabilities: list = [],
    weaknesses: list = [],
    attacks: list = [],
) -> dict:

    exploit_target = ExploitTargetDataSchema().load(
        {
            "id": stix_id,
            "type": "exploit-target",
            "title": title,
            "description": description,
            "producer": producer,
            "vulnerabilities": vulnerabilities,
            "weaknesses": weaknesses,
        }
    )

    entity_meta = {
        "estimated_observed_time": observed_time,
        "estimated_threat_start_time": threat_start_time,
        "estimated_threat_end_time": threat_end_time,
        "half_life": half_life,
        "tags": tags,
        "taxonomy": taxonomy,
        "attack": attacks,
        "tlp_color": tlp_color,
        "bundled_extracts": extracts,
        "extraction_ignore_paths": extraction_ignore_paths,
    }

    entity_data = EntitySchema().load(
        {
            "data": exploit_target,
            "meta": entity_meta,
        }
    )

    return entity_data


def remove_empty_extracts(extracts):
    to_return = []
    for extract in extracts:
        if extract:
            to_return.append(extract)
    return to_return


def add_time(
    data: dict,
    observed_time: str = None,
    threat_start_time: str = None,
    threat_end_time: str = None,
):
    if observed_time:
        data["meta"]["estimated_observed_time"] = observed_time
    if threat_start_time:
        data["meta"]["estimated_threat_start_time"] = threat_start_time
    if threat_end_time:
        data["meta"]["estimated_threat_end_time"] = threat_end_time


def create_vulnerability_report(report: dict) -> dict:
    cve_report = report["data"]["cve_report"]
    tags, extracts = [], []
    role, references = get_roles_references(cve_report)
    timestamp = datetime.datetime.utcfromtimestamp(report["activity"]["first"] / 1000)
    if report.get("classification"):
        tags = create_intel_requirements_tags(
            report["classification"].get("intel_requirements")
        )
    tags.append("Vulnerability Report")
    cve_value = cve_report["name"].replace("CVE-", "")
    cve_extract = {
        "kind": ExtractType.CVE.value,
        "value": cve_value,
        "classification": "safe",
    }

    if cve_extract:
        extracts = [cve_extract]

    _id = "{{https://intel471.com/}}Report-{}".format(
        str(uuid.uuid5(uuid.NAMESPACE_X500, str(cve_report["name"])))
    )
    producer = create_producer(
        "Intel 471 Vulnerability Intelligence",
        references=references,
        role_values=[role],
    )

    vulnerability_report = create_report(
        _id,
        f'Intel 471 Vulnerability Report - {cve_report["name"]}',
        short_description=f'<p>{cve_report["underground_activity_summary"]}</p>',
        description=create_report_analysis(report),
        intents=["Exploit Characterization"],
        producer=producer,
        extracts=extracts,
        tags=tags,
        observed_time=timestamp.isoformat(),
        threat_start_time=timestamp.isoformat(),
    )
    return vulnerability_report


def create_report(
    stix_id: "",
    title: "",
    description: str = "",
    short_description: str = "",
    producer: dict = {},
    observed_time: str = "",
    threat_start_time: str = "",
    threat_end_time: str = "",
    timestamp: str = "",
    extracts: list = [],
    tags: list = [],
    summary: str = "",
    intents: list = [],
    extraction_ignore_paths: list = [],
    attachments: list = [],
    tlp_color: str = "NONE",
    half_life: int = 1,
    observable: list = [],
    taxonomy: list = [],
    taxonomy_paths: list = [],
    relationship: str = "",
    attacks: list = [],
) -> dict:

    report = {
        "id": stix_id,
        "type": "report",
        "title": title,
        "description": description,
        "short_description": short_description,
        "producer": producer,
        "timestamp": timestamp,
        "intents": intents,
    }

    entitiy_meta = {
        "estimated_observed_time": observed_time,
        "estimated_threat_start_time": threat_start_time,
        "estimated_threat_end_time": threat_end_time,
        "half_life": half_life,
        "tags": tags,
        "taxonomy": taxonomy,
        "attack": attacks,
        "tlp_color": tlp_color,
        "bundled_extracts": extracts,
        "extraction_ignore_paths": extraction_ignore_paths,
    }

    entitiy_data = EntitySchema().load(
        {"data": report, "meta": entitiy_meta, "attachments": attachments}
    )

    return entitiy_data


def create_report_analysis(report: dict) -> str:
    cve_report = report["data"]["cve_report"]
    title = f'<p>Intel 471 Vulnerability Report {cve_report["name"]}<p>'
    analysis = (
        f"<h4>ANALYSIS *</h4>"
        f"<p>The CVE has been determined"
        f' as {cve_report["risk_level"]} risk level.</p>'
    )
    cve_details = (
        f"<h1><b>CVE Details:</b></h1>"
        f'<p>Vendor Name: {cve_report["vendor_name"]}</p>'
        f'<p>Product Name: {cve_report["product_name"]}</p>'
        f'<p>CVE Type: {cve_report["cve_type"]}</p>'
        f'<p>CVE Status: {cve_report["cve_status"]}</p>'
    )

    activity_location = "<h1><b>Activity Location</b></h1>"
    if cve_report["activity_location"].get("location_opensource"):
        activity_location += (
            f"<p>Opensource: "
            f'{cve_report["activity_location"]["location_opensource"]}</p>'
        )
    if cve_report["activity_location"].get("location_underground"):
        activity_location += (
            f"<p>Underground: "
            f'{cve_report["activity_location"]["location_underground"]}</p>'
        )
    if cve_report.get("underground_activity"):
        activity_location += (
            f"<p>Underground Activity: " f'{cve_report["underground_activity"]}</p>'
        )

    exploit_status = "<h1><b>Exploit Status</b></h1>"
    report_exploit_status = cve_report["exploit_status"]
    if "available" in cve_report["exploit_status"].keys():
        exploit_status += f'<p>Available: {report_exploit_status["available"]}</p>'
    if "weaponized" in cve_report["exploit_status"].keys():
        exploit_status += f'<p>Weaponized: {report_exploit_status["weaponized"]}</p>'

    exploit_status += (
        f'<p>Patch Status: {cve_report["patch_status"]}</p>'
        f'<p>Proof of Concept: {cve_report["poc"]}</p>'
        + create_poc_links_analysis(
            cve_report["poc_links"] if "poc_links" in report.keys() else []
        )
    )
    interest_level = (
        f"<h1><b>Interest Level:</b></h1>"
        f"<p>Disclosed Publicly: "
        f'{cve_report["interest_level"]["disclosed_publicly"]}</p>'
        f"<p>Researched Publicly: "
        f'{cve_report["interest_level"]["researched_publicly"]}</p>'
    )
    recommendations = (
        f"<h4>RECOMMENDATIONS *</h4>" f'<p>{cve_report["counter_measures"]}</p>'
    )
    return "".join(
        [
            title,
            analysis,
            cve_details,
            activity_location,
            exploit_status,
            interest_level,
            recommendations,
        ]
    )


def create_poc_links_analysis(poc_links: list) -> str:
    return "".join(
        [
            f"<p>Proof of Concept Link: <a href={link['url']}>{link['title']}</a></p>"
            for link in poc_links
        ]
    )


intel_requirements_map = {
    "1.1.1": "Ransomware malware",
    "1.1.2": "Mobile malware",
    "1.1.3": "Remote Access Trojan (RAT) malware",
    "1.1.4": "Banking trojan malware",
    "1.1.5": "Information stealer malware",
    "1.1.6": "Loader malware",
    "1.1.7": "Botnet malware",
    "1.1.8": "Worm malware",
    "1.1.9": "Point-Of-Sale (PoS) malware",
    "1.1.10": "ATM malware",
    "1.1.11": "Internet of Things (IoT) malware",
    "1.1.12": "Denial of Service (DoS) malware",
    "1.1.13": "Proxy malware",
    "1.1.14": "Destructive malware",
    "1.1.15": "Cryptomining malware",
    "1.1.16": "Formgrabber, Web Inject, Automatic Transfer Systems (ATS) malware",
    "1.2.1": "Multifunctional Malware-as-a-Service (MaaS) platforms",
    "1.2.2": "Crypter/FUD services",
    "1.2.3": "Anti/Counter-AV services",
    "1.2.4": "Ransomware-as-a-Service (RaaS)",
    "1.2.5": "Spamming services",
    "1.2.6": "DoS/booter/stresser services",
    "1.2.7": "Rogue Code Signing certificate providers",
    "1.2.8": "Rogue Web certificate providers",
    "1.3.1": "Malware install providers",
    "1.3.2": "Malvertising",
    "2.1.1": "Operating System (OS) vulnerabilities",
    "2.1.1.1": "Desktop/Server OS vulnerabilities",
    "2.1.1.2": "Mobile OS vulnerabilities",
    "2.1.2": "Software and web application vulnerabilities",
    "2.1.2.1": "Web browser vulnerabilities",
    "2.1.2.2": "Office / productivity software vulnerabilitie",
    "2.1.2.3": "Open source software library vulnerabilities",
    "2.1.3": "Protocol vulnerabilities",
    "2.1.4": "Server platform vulnerabilities",
    "2.1.4.1": "Database server vulnerabilities",
    "2.1.4.2": "Web server vulnerabilities",
    "2.1.4.3": "Email server vulnerabilities",
    "2.1.4.4": "Content management server vulnerabilities",
    "2.1.5": "Network appliance / endpoint vulnerabilities",
    "2.1.6": "Cloud computing / storage vulnerabilities",
    "2.1.7": "Hardware vulnerabilities",
    "2.1.8": "Other platform vulnerabilities",
    "2.1.8.1": "Transportation controls vulnerabilities",
    "2.1.8.2": "Industrial controls systems vulnerabilities",
    "2.1.8.3": "IoT-related vulnerabilities",
    "2.1.8.4": "Healthcare systems related vulnerabilities",
    "2.2.1": "Exploit Proof-of-concept (PoC) code",
    "2.2.2": "Exploit kits",
    "3.1.1": "Bulletproof Hosting (BPH) services",
    "3.1.2": "Proxy services",
    "3.1.3": "Domain registrar services",
    "3.1.4": "Botnet services",
    "4.1.1": "Cash-out services",
    "4.1.2": "Money laundering and exchange services",
    "4.1.3": "Money mule accounts and networks",
    "4.1.4": "Bank account drops and fund transfers",
    "4.1.5": "Prepaid cards / gift cards",
    "4.1.6": "Travel fraud",
    "4.1.7": "Hospitality fraud",
    "4.1.8": "Tax fraud",
    "4.1.9": "CEO/CFO fraud / Business Email Compromise (BEC)",
    "4.1.10": "Documentation fraud",
    "4.1.11": "Insurance fraud",
    "4.2.1": "Compromised payment cards (CVVs, fullz, dumps)",
    "4.2.2": "Compromised account credentials",
    "4.2.3": "Compromised Personally Identifiable Information (PII)",
    "4.2.4": "Compromised Intellectual Property (IP)",
    "4.3.1": "Call center services",
    "4.3.2": "Account checking services",
    "4.3.3": "Brute force tools",
    "4.3.3.1": "Credential stuffing",
    "4.4.1": "Phishing",
    "4.4.2": "Spearphishing",
    "4.4.3": "Vishing",
    "4.4.4": "Social media scams",
    "4.4.5": "Smishing",
    "5.1.1": "Reconaissance & information gathering (Att&ck)",
    "5.1.2": "Weaponization (Att&ck)",
    "5.1.3": "Delivery (Att&ck)",
    "5.2.1": "Initial Access (Att&ck)",
    "5.2.2": "Execution (Att&ck)",
    "5.2.3": "Persistence (Att&ck)",
    "5.2.4": "Privilege Escalation (Att&ck)",
    "5.2.5": "Defense Evasion (Att&ck)",
    "5.2.6": "Credential Access (Att&ck)",
    "5.2.7": "Discovery (Att&ck)",
    "5.2.8": "Lateral Movement (Att&ck)",
    "5.2.9": "Collection (Att&ck)",
    "5.2.10": "Exfiltration (Att&ck)",
    "5.2.11": "Command and Control (Att&ck)",
    "5.3.1": "Denial of Service (DoS) attacks",
    "5.3.2": "Injection attacks",
    "5.3.3": "Website defacements",
    "5.3.4": "Brute Force Attacks",
    "5.4.1": "ATM attacks: skimming, shimming, jackpotting",
    "5.4.2": "PoS attacks: skimming",
    "5.4.3": "Physical sabotage of network / system",
    "5.5": "Insider threats",
    "5.6.1": "Espionage",
    "5.6.2": "Outsider trading",
    "5.6.3": "Information or data breach",
    "6.1.1": "Consumer & Industrial Products",
    "6.1.1.1": "Consumer Business",
    "6.1.1.2": "Aviation & Transportation",
    "6.1.1.3": "Consumer Products",
    "6.1.1.4": "Sports & Leisure",
    "6.1.1.5": "Hospitality",
    "6.1.1.6": "Restaurants & Food Service",
    "6.1.1.7": "Retail, Wholesale & Distribution",
    "6.1.2": "Energy & Resources",
    "6.1.2.1": "Oil. Gas, and Consumable Fuels",
    "6.1.2.2": "Power & Utilities",
    "6.1.2.3": "Shipping & Ports",
    "6.1.2.4": "Water",
    "6.1.3": "Financial Services",
    "6.1.3.1": "Banking & Securities",
    "6.1.3.2": "Insurance",
    "6.1.3.3": "Investment Management",
    "6.1.4": "Life Sciences & Health Care",
    "6.1.4.1": "Health Care Providers and Services",
    "6.1.4.2": "Health Care Equipment and Technology",
    "6.1.4.3": "Pharmaceuticals, Biotechnology and Life Sciences",
    "6.1.5": "Manufacturing",
    "6.1.5.1": "Aerospace & Defense",
    "6.1.5.2": "Automotive",
    "6.1.5.3": "Industrial Products & Services",
    "6.1.5.4": "Chemicals & Specialty Materials",
    "6.1.6": "Public Sector",
    "6.1.6.1": "International Government",
    "6.1.6.2": "National Government",
    "6.1.6.3": "Regional Government",
    "6.1.6.4": "Education",
    "6.1.6.5": "Public Safety",
    "6.1.6.6": "Military and Defense",
    "6.1.7": "Real Estate",
    "6.1.7.1": "Engineering and Construction Industry",
    "6.1.7.2": "Real Estate Fund and Investor",
    "6.1.7.3": "REIT and Property Company",
    "6.1.7.4": "Real Estate Management, Brokerage, and Service Provider",
    "6.1.7.5": "Tenants and Occupiers",
    "6.1.8": "Technology, Media & Telecommunications",
    "6.1.8.1": "Technology",
    "6.1.8.2": "Media & Entertainment",
    "6.1.8.3": "Communications",
    "6.1.8.4": "Internet of Things",
    "6.1.9": "Professional Services & Consulting",
    "6.1.9.1": "IT/Technology Consulting",
    "6.1.9.2": "Management & Operations Consulting",
    "6.1.9.3": "Financial & Investment Consulting",
    "6.1.9.4": "Human Resources Consulting",
    "6.1.9.5": "Marketing & Sales Consulting",
    "6.1.9.6": "Law Services & Consulting",
    "6.1.9.7": "Political Consulting",
    "6.1.9.8": "Physical Security Consulting",
    "6.2.1": "Africa",
    "6.2.2": "Asia",
    "6.2.3": "Central America",
    "6.2.4": "Europe",
    "6.2.5": "European Union",
    "6.2.6": "Middle East",
    "6.2.7": "North America",
    "6.2.8": "Oceania",
    "6.2.9": "South America",
    "6.2.10": "The Caribbean",
}
